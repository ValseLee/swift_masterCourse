### 메모리 관리
> 스위프트는 값 타입과 참조 타입을 사용한다.

- 값 타입은 필요할 때마다 메모리의 '값'이 복사되어서 전달되고 그 값은 `Stack` 저장된다.
  스택 프레임이 끝날 때마다 메모리에서 자동 제거되었다.

- 참조 형식은 클래스와 클로저 뿐이다. '값'은 Heap에 저장되고 '주소'를 `Stack` 저장한다.
  이 메모리는 ARC 모델을 통해 관리한다. `Refernce Counting` 참조 숫자를 자동으로 관리!

---
### 메모리 구조의 재고찰
- 코드 영역 : 코드 영역은 Read-Only로서 CPU에 전달할 명령어들이 위치한다.
  코드의 명령어가 요구하는 특정 값 또는 주소는 데이터, 힙, 스택 영역에 각각 저장된다.

- 데이터 영역 : 전역 변수 - 타입 변수가 저장된다.
  앱이 실행되는 동안 **불변**하며 공통 사용을 위한 목적으로 존재한다.

- 힙 영역 : 힙 영역의 데이터는 일반적으로 오랫동안 저장된다.
  차곡차곡 쌓이는 게 아니라 **동적할당**된다.
  크기가 크고 관리가 필요하다. 힙 영역에 할당되는 데이터는 관리를 꼭 해주어야 메모리에서 해제된다.
  할당이 해제되지 않는 힙 때문에 `메모리 누수`가 발생한다.
  
- 스택 영역 : 함수를 실행할 때 스택 프레임이 호출되어 크기가 작은 데이터들을 빠르게 사용하는 영역
  함수 실행을 위한 임시 공간이며 자동으로 알아서 메모리 관리가 된다.

그래서 힙 영역의 메모리를 어떻게 관리할 것인가?

---
### ARC Model
|Java|ObjC|Swift|
|:---:|:---:|:---:|
|GC<br>Garbage Collector|MRC<br>ARC|ARC|

1. Java GC : 힙을 주기적으로 스캔해서 쓰지 않는, 쓰지 않게 될 메모리를 검사하여 메모리를 감시
이 스캔 주기를 우리는 알지 못하고 이 스캔 시간 때문에 느린 편
2. Objc MRC,ARC : MRC는 개발자가 직접 코드를 넣어서 참조 숫자를 카운트했다.
ARC는 참조 숫자를 자동으로 카운트해서 메모리 관리, 컴파일 시에 메모리 해체 시점을 결정함
물론 '완전히 자동'이 아니라 '숫자를 세준다' 는 것. **어떤 참조 관계를 어떻게 세야 할지는 개발자가 구현해줘야 한다**.

그럼 어떤 메커니즘이 자동으로 숫자를 센다는 건가?