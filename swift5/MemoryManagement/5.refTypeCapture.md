### 참조 타입 캡쳐와 캡쳐리스트

```swift
class Some {
    var num = 0
}

// 각 인스턴스를 힙에 생성하고 그 주소를 x와 y에 각각 할당
var x = Some()
var y = Some()

// 이 중에 변수 x만 캡쳐리스트에 담아보자
// 이렇게 해서 클로저 외부에 있는 참조 타입(x)의 주소값을 복사해서 쓸 수 있다.
// 그러면 참조 타입 내의 속성을 쓸 때, 해당 속성이 위치한 스택 영역을 경유할 필요가 없다.
// 그런데 클로저도 힙 내의 인스턴스를 참조하고, 스택도 힙 인스턴스를 참조하기 때문에 RC가 처음부터 2가 된다.
// 덕분에 인스턴스가 사라져도 클로저는 남는 거야
// 이건 마찬가지로 강한 참조 때문인데, 약한 참조를 하는 방법은 아래에서 볼 수 있다.
let refTypeCapt = { [x] in 
    print("참조 출력 :", x.num, y.num)
}

// 두 값을 모두 똑같이 바꾸면 
x.num = 1
y.num = 1

// 당연히 1,1로 나오겠지
print(x.num, y.num) // 1, 1
```

클로저는 힙 영역에 x, y를 갖고 자리를 잡는다.
y는 스택 영역의 y 변수가 갖고 있는 인스턴스의 주소를 참조한다.
그러나 y 변수 안에는 num이 없기 때문에 y 변수는 다시 힙에 있는 y 인스턴스의 실제 속성을 참조한다.

캡쳐리스트를 따로 만들지 않으면 클로저 내에서 캡쳐된 값들을 찾아다니는 리소스 낭비가 있다는 거야.
캡쳐리스트 x는 주소를 클로저가 직접 갖고 있기 때문에 힙에서만 움직인다.

---
### 강한 참조 사이클 문제
여기서도 weak과 unowned로 해결한다.
그런데 어떻게?

```swift
var z = Some()

// 약한 참조를 해도 상관은 없는데 인스턴스가 사라지면 nil이 되어야 한다.
// 그래서 클로저 내부의 캡쳐리스트에 담긴 인스턴스는 옵셔널로 써주도록 한다.
// 예시로 쓴 이 코드들에서는 강한 참조가 발생하진 않는다.
// 클래스끼리 서로 참조하고 있는 사이클이 없으니까.
// 캡쳐리스트 내에서 바인딩도 가능함!
let refTypeCapt1 = { [weak i = z] in 
    print(i?.num)
}
```