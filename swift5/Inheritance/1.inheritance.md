### Inheritance
---
상속은 본질적으로 성격이 비슷한 클래스 타입을 새로 만드는 행위
**값 타입인 struct는 상속할 수 없고 열거형도 불가능하다.**
영어로는 `Subclassing` 한다고 표현

#### [수직 확장]
1. 데이터, **저장속성**을 추가
2. 기능을 변형시켜 사용하기 위해 활용

A 클래스를 만들고 B, C 클래스를 만들었다.
A 클래스에 id, name, email 저장 속성,
B 클래스에 A 클래스의 저장 속성에 student 저장 속성 추가
C 클래스는 B 클래스의 저장 속성에 major 저장 속성 추가
... 이런 식으로 이전 클래스의 속성을 다음 클래스로 넘겨주는 것
그러나 엄밀히 말하면 각각 **서로 다른 클래스**라는 점을 잊지 말것

메모리 저장 공간을 점유하는 저장 속성이 상속된다면.. 당연히 **메모리 공간도 커진다**.
__재정의가 불가능하다는 것은 기존 메모리 저장 공간을 유지한다는 의도가 숨어있다.__
자식 클래스는 다른 부모 클래스는 만들 수 없다. 한 번 부모가 정해지면 바꿀 수 없듯
그런데 하나의 부모 클래스는 여러 자식 클래스는 둘 수 있다(다형)

#### 재정의
부모 클래스의 멤버를 변형하는 것을 **재정의**라고 함
재정의 대상 멤버에는 override 키워드를 꼭 붙여야 한다.
**그러나 저장 속성은 재정의할 수 없고 그저 추가만 가능하다.**
메소드는 재정의가 가능하다. 추가 변형도 가능하다.
재정의 된 메소드의 메모리 주소는 기존의 것과 다르다.

---
```swift
class Person { // 최초의 클래스 = base class // 상속받지 않는 클래스 // 부모 클래스
    var id = 0
    var name = "name"
    var email = "hi@naver.com"
}

class Student: Person { // 다른 클래스의 타입을 상속한 '자식, 서브' 클래스 // Graduate의 부모 클래스
    // 다른 클래스의 타입을 명시하여 해당 클래스의 저장 속성을 상속
    // id, name, email
    // 상위 클래스의 저장속성을 참조할 수 있으며 코드에서 생략할 수 있다.
    // 그러나 실제로 갖고 있는 것은 아니어서 재정의가 불가능하다.
    // 반면 메소드는 메모리 주소를 데리고 온다.
    var studentId = 0 
    
}

final class Graduate: Student { // Student의 '자식 클래스' // 
    var major = "전공"
    // 다른 클래스가 Graduate를 상속하지 못하도록 하는 키워드 final을 사용할 수 있다.
    // 특정 저장 속성만 상속을 막고 싶다면 변수 앞에 final을 사용하자.
} // 더 이상 자식을 둘 수 없는 클래스!

```
---

### UIKit의 상속 구조
애플의 코코아터치 프레임워크인 UIKit는.. 어떻게 클래스 상속하고 있을까?
그 시초는 ObjC이고 아주 오랫동안 개선과 증축을 이어왔다.
UIKit Hierarchy를 참고하면 좋다. NSObject를 시작으로 ... 매우 복잡하게 구조가 짜여져 있다.

- UIResponder -> UiViewController, UIView ...
    + UIView -> UIControl, UIImageView, UILabel ...
        * UIControl -> UIButton, UITextField, UISwitch ...
만약 UIControl에 `backgroundColor` 관련 속성이 있다면, 이를 상속한 클래스는 모두 갖고 있을 것이라 유추가 가능