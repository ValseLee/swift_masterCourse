/*
 메모리의 비트 단위로 직접적인 논리연산.
 비트의 단위를 이동할 때 사용하는 연산자.
 연산속도가 매우 빠르고 짧은 코드로 복잡한 로직을 구현할 수도 있다.

 [비트논리]
 ~(NOT) : 단항 연산자. 기존 메모리의 비트를 반전시킴
 &(AND) : 2개의 메모리 비트 중 모두가 1이면 1을 반환
 |(OR) : 2개의 메모리 비트 중 하나라도 1이면 1을 반환
 ^(XOR) : 2개의 메모리 비트를 비교해서 서로 다르면 1을 반환, 서로 같으면 0 반환 ✨

 [비트이동]
 >> : Right Shift
 << : Left Shift
 */

let k = 0b0000_1111 // 15
let kNeg = ~k // 0b1111_0000
print(kNeg) // -16

let a: UInt8 = 0b1111_1100 // 252
let b: UInt8 = 0b0011_1111 // 63
let m = a & b
print(m) // 0b0011_1100 // 60

var i: UInt8 = 0b1011_0010 // 178
var j: UInt8 = 0b0101_1110 // 94
let p = i | j
print(p) // 0b1111_1110 // 254

// XOR
let q = i ^ j
print(q) // 0b1110_1100 // 236

// 부호가 없을 때의 비트 이동
i = 0b1111_1111
j = i << 1
print(j) // 0b1111_1110 // 254
j = i << 2
print(j) // 0b1111_1100 // 252

i = 4
print(i << 1) // 8 	(2의 1승을 곱해줌)
print(i << 2) // 16 (2의 2승을 곱해줌)
print(i << 4) // 64 (2의 4승을 곱해줌)
print(i >> 1) // 2  (2의 1승을 나눠줌)

/*
 부호가 있을 때의 비트 이동✨
 왼쪽 이동은 자동으로 부호를 유지하며, 부호가 없을 때와 동일하게 동작한다.
 오른쪽 이동을 하면서 부호 유지를 해야 한다.
 */

var num: Int8 = 4
num >> 1 // -1
num >> 2 // -1
num >> 5 // -1
