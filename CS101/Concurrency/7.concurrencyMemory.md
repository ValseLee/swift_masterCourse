### 동시성 프로그래밍의 메모리구조와 문제
코데힙스에서 스택이 각 쓰레드로 인해 추가될 수 있고
스택은 서로 교차 참조는 안 된다는 점

1. 경쟁상황과 경쟁조건(Race Condition)
- 서로 다른 쓰레드에서 같은 시점에 하나의 메모리(데이터 혹은 힙)에 동시에 접근하는 문제
- 2번 쓰레드는 특정 속성에 '쓰기' 를 진행하는데 동일 시점에 3번 쓰레드는 '읽기'를 한다면?
- 이 사이에서 **우선순위는 정해져있지 않다**.
- 이를 경쟁상황이라 하고 Thread-Safe 하지 않다고 한다.
- 그래서 '쓰기'가 진행중일 때는 다른 쓰레드에서 동일 시점에 접근하지 못하도록 'Lock' 처리를 할 수 있다.
- 그외에도 순서를 정해주는 등 여러 방법은 가능하다.

2. 교착상태(deadlock)
- 배타적 메모리 사용으로 일이 진행되지 않는 문제
- 경쟁상황을 방지하려고 Lock 처리를 했는데 서로 다른 쓰레드에서 실행되는 메소드가 각각 Lock을 해버리는 바람에 아무런 일도 진행되지 못하는 상황이다.
- 2개 이상의 쓰레드가 서로 배타적인 메모리 사용으로 메소드 작업이 종료도 안되고 진행도 안 되어서 앱이 멈춰버린다.

### 해결방안
각 작업들을 비동기처리를 했다고 가정하자.
서로 다른 스택이 생성될 것이고, 경쟁상황이 생길 우려가 커진다.
여러 쓰레드에서 동시에 메모리에 접근할 우려가 있다면 그 작업들을 직렬 큐에 보내 버리자.

```swift
var array = [String]()
let serialQueue = DispatchQueue(label: "serial")

for i in 1 ... 20 {
    DispatchQueue.global().async {
        print("\(i)")

        /*
        array.append("\(i)") 를 쓰게 되면 동시에 array에 i를 어펜드하게 된다.
        경쟁상황으로 인해서 append 가 제대로 실행되지 않고 어펜드되지 않는 i가 생긴다.
        즉, 코드에 결점이 생긴다!!!
        */ 
        
        // 직렬큐 처리
        // 비동기에서 동기로 넘어가더라도, 순서는 보장되지 않는다는 점!
        serialQueue.async {
            array.append("\(i)")
        }
    }
}
```
### 왜 UI는 메인 쓰레드가 관리할까?
UIKit의 모든 속성을 Thread-safe하게 설계하면.. 느려질 수 있다.
메인 런루프가 뷰 업데이트를 관리하는 View Drawing Cycle로 뷰를 동시에 업데이트 하는 설계를 담당한다.
만약 메인 런루프가 아닌 백그라운드 쓰레드가 각자의 런루프로 UI를 그리면 뷰가 제멋대로 돌아다닐 수도 있다.
iOS의 렌더링 프로세스는 여러 쓰레드에서 각자의 뷰 변경사항을 GPU로 보낼 때 느려지거나 비효율적으로 작동할 수 있다.
그 정보를 다 일일이 봐야하니까.
Texture, ComponentKit 등등 메타에서 만든 비동기 UI 프레임워크가 있긴 한데 .. 위와 같은 이유들로 메인 쓰레드에서
동시 업데이트 된다.