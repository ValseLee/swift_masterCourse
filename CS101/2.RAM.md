### RAM
---
1. 대략적 작동구조
   - 코드가 RAM의 a주소에 순서대로 저장된다.
   - CPU 내의 Programm Counter가 코드의 주소를 MAR(메모리주소레지스터)로 가져온다.
     - 제어장치로 전달된 이 코드는 '한줄한줄' 실행되도록 통제된다.
   - MAR가 주소를 찾아가고 명령을 발견하여 가져온다.
   - MBR(메모리버퍼레지스터)로 전달된다.
     - MOV A, 3(명령과 메모로 구성됨)
     - 메모리의 명령과 주소가 전달됨
   - IR(명령레지스터)에 MOV을 메모리에 저장한다.
   - 실제 명령 해독기(ID)가 해석한다.
     - 연산장치로 보내서 작동시킨다.
     - 연산장치가 3이라는 결과를 스택으로 보내서 저장한다.
  ---
2. **RAM(휘발성 메모리)**
   - OS가 제일 먼저 RAM에 자동으로 올라옴
   - 앱 실행 시키면, 코드, 데이터, 힙, 스택을 차지한다.
     - 프로세스마다 모두 다른 코데힙스를 점유한다.
   - 각 영역은 앱 하나하나가 차지하는 메모리 영역이다.
 - **ROM(비휘발성 메모리)의 역할**
   - POST(자기자신을 점검)
   - ROM-BIOS(기본 입출력 활성화)
   - 부팅(OS를 메모리에 올려줌)
---
3. Cashe
  - CPU와 RAM 사이의 선(BUS) 때문에 CPU 속도는 느려진다.
  - RAM 영역의 일부 메모리를 Cashe에 옮겨두고 RAM으로 중개되는 과정을 생략하여 CPU 속도를 관리
  - 이로써 RAM 과의 소통이 더 빨라진다.
---
4. Compile
   - 컴퓨터가 알아들 수 있도록 코드를 기계어로 컴파일
   - 초창기 코드는 실제로 기계어를 일일이 쓰면서 작성해왔다.
   - 시맨틱 하지 않았기 때문에.. 저급언어인 어셈블리어가 등장하게 된다.
     - 기계어를 인간이 최소한으로 읽을 수 있는 형태로 표현
     - 기계어와 인간어가 1:1를 매칭!
     - 메모리를 일일이 관리해야 하는 어려움
   - 편의성 수요가 늘어가며 고급언어 등장
     - 인간이 논리적 생각대로 코드를 짤 수 있는 형태